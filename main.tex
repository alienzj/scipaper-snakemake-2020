%\documentclass[parskip=half, DIV=18]{scrartcl}
\documentclass[10pt,a4paper,twocolumn]{article}
\usepackage{f1000_styles}

\usepackage[utf8]{inputenc}
%\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{authblk}
\PassOptionsToPackage{hyphens}{url}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\lstset{basicstyle=\ttfamily}
\usepackage{enumitem}
\setlist[enumerate]{itemsep=0mm}
\setlist[itemize]{itemsep=0mm}

\usepackage[maxbibnames=999,backend=bibtex,url=false,doi=true,isbn=true]{biblatex}
\addbibresource{literature.bib}

\newcommand{\sharedfirst}{$\dagger$}
\newcommand{\sharedfirsttext}[1]{\affil[\sharedfirst]{#1}}
\newcommand{\corresponding}{*}
\newcommand{\correspondingtext}[1]{\affil[\corresponding]{#1}}
\newcommand{\image}[1]{\centering\includegraphics[width=\textwidth]{#1}}
\let\plainurl\url
\renewcommand{\url}[1]{\protect\plainurl{#1}}

\begin{document}

\author[1,2]{Felix Mölder}
\author[3,4]{Kim Philipp Jablonski}
\author[5]{Brice Letcher}
\author[5]{Michael B. Hall}
\author[6,7]{Christopher H. Tomkins-Tinch}
\author[8]{Vanessa Sochat}
\author[1,9]{Jan Forster}
\author[10]{Soohyun Lee}
\author[11]{Sven~O.~Twardziok}
\author[12,13]{Alexander Kanitz}
\author[14]{Andreas Wilm}
\author[15,11]{Manuel Holtgrewe}
\author[16]{Sven Rahmann}
\author[17]{Sven Nahnsen}
\author[1,18,\corresponding]{Johannes Köster}

\affil[1]{Algorithms for reproducible bioinformatics, Genome Informatics, Institute of Human Genetics, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\affil[2]{Institute of Pathology, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}

\affil[3]{Department of Biosystems Science and Engineering, ETH Zurich, Basel, Switzerland}
\affil[4]{Swiss Institute of Bioinformatics (SIB), Basel, Switzerland}

\affil[5]{EMBL-EBI, Hinxton, UK}

\affil[6]{Broad Institute of MIT and Harvard, Cambridge, USA}
\affil[7]{Department of Organismic and Evolutionary Biology, Harvard University, Cambridge, USA}

\affil[8]{Stanford University Research Computing Center, Stanford University, Stanford, USA}

\affil[9]{German Cancer Consortium (DKTK, partner site Essen) and German Cancer Research Center, DKFZ, Heidelberg, Germany}

\affil[10]{Biomedical Informatics, Harvard Medical School, Harvard University, Boston, USA}

\affil[11]{Charité - Universitätsmedizin Berlin, corporate member of Freie Universität Berlin, Humboldt-Universität zu Berlin, and Berlin Institute of Health (BIH), Center for Digital Health, Berlin, Germany}

\affil[12]{Biozentrum, University of Basel, Switzerland}
\affil[13]{SIB Swiss Institute of Bioinformatics / ELIXIR Switzerland, Lausanne, Switzerland}

\affil[14]{Microsoft Singapore, Singapore}

\affil[15]{CUBI – Core Unit Bioinformatics, Berlin Institute of Health, Berlin, Germany}

\affil[16]{Genome Informatics, Institute of Human Genetics, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}

\affil[17]{Quantitative Biology Center (QBiC), University of Tübingen, Tübingen, Germany}

\affil[18]{Medical Oncology, Harvard Medical School, Harvard University, Boston, USA}

\correspondingtext{To whom correspondence should be addressed}

\title{Sustainable data analysis with Snakemake}
\maketitle
\thispagestyle{fancy}

\begin{abstract}
	Data analysis often entails a multitude of heterogeneous steps, from the application of various command line tools to the usage of scripting languages like R or Python for the generation of plots and tables.
	It is widely recognized that data analyses should ideally be conducted in a reproducible way.
	Reproducibility enables technical validation and regeneration of results on the original or even new data.
	However, reproducibility alone is by no means sufficient to deliver an analysis that is of lasting impact (i.e., sustainable) for the field, or even just one research group.
	We postulate that it is equally important to ensure adaptability and transparency.
	The former describes the ability to modify the analysis to answer extended or slightly different research questions.
	The latter describes the ability to understand the analysis in order to judge whether it is not only technically, but methodologically valid.

	Here, we analyze the properties needed for a data analysis to become reproducible, adaptable, and transparent.
	We show how the popular workflow management system Snakemake can be used to guarantee this, and how it enables an ergonomic, combined, unified representation of all steps involved in data analysis, ranging from raw data processing, to quality control and fine-grained, interactive exploration and plotting of final results.
\end{abstract}

\section*{Keywords}

data analysis, workflow management, sustainability, reproducibility, transparency, adaptability, scalability

\clearpage

\section{Introduction}\label{sec:introduction}

Despite the ubiquity of data analysis across scientific disciplines, it is a challenge to ensure \emph{in silico} reproducibility~\parencite{Mesirov2010,Baker2016,Munaf__2017}.
By automating the analysis process, workflow management systems can help to achieve such reproducibility.
Consequently, a ``Cambrian explosion'' of diverse scientific workflow management systems is in process; some are already in use by many and evolving, and countless others are emerging and being published (see~\url{https://github.com/pditommaso/awesome-pipeline}).
Existing systems can be partitioned into five niches which we will describe below, with highlighted examples of each.

First, workflow management systems like Galaxy~\parencite{Afgan2018} and KNIME~\parencite{wiswedel2007} offer graphical user interfaces for composition and execution of workflows.
The obvious advantage is the shallow learning curve, making such systems accessible for everybody, without the need for programming skills.

Second, with systems like Anduril~\parencite{Cervera2019}, Balsam~\parencite{papka2018}, Hyperloom~\parencite{cima2018hyperloom}, Jug~\parencite{Coelho_2017}, Pwrake~\parencite{Tanaka_2010}, Ruffus~\parencite{Goodstadt2010}, SciPipe~\parencite{Lampa2019}, SCOOP \parencite{SCOOP_XSEDE2014}, and COMPSs~\parencite{Lordan_2013} workflows are specified using a set of classes and functions for generic programming languages like Python, Scala, and others.
Such systems have the advantage that they can be used without a graphical interface (e.g. in a server environment), and that workflows can be straightforwardly managed with version control systems like Git (\url{https://git-scm.com}).

Third, with systems like Nextflow~\parencite{Di_Tommaso_2017}, Snakemake~\parencite{Koester2012}, BioQueue~\parencite{Yao2017}, Bpipe~\parencite{Sadedin2012}, ClusterFlow~\parencite{Ewels2016}, Cylc~\parencite{J_Oliver_2018},~and BigDataScript~\parencite{Cingolani_2014}, workflows are specified using a domain specific language (DSL).
Here, the advantages of the second niche are shared, while adding the additional benefit of improved readability; the DSL provides statements and declarations that specifically model central components of workflow management, thereby obviating superfluous operators or boilerplate code.
For Nextflow and Snakemake, since the DSL is implemented as an extension to a generic programming language (Groovy and Python), access to the full power of the underlying programming language is maintained (e.g. for implementing conditional execution and handling configuration).

Fourth, with systems like Popper~\parencite{Jimenez_2017}, workflow specification happens in a purely declarative way, via configuration file formats like YAML~\parencite{Evans2009-vp}.
These declarative systems share the concision and clarity of the third niche.
In addition, workflow specification can be particularly readable for non-developers.
The caveat of these benefits is that by disallowing imperative or functional programming, these workflow systems can be more restrictive in the processes that can expressed.

Fifth, there are system-independent workflow specification languages like CWL~\parencite{cwl} and WDL~\parencite{voss_full-stack_2017}.
These define a declarative syntax for specifying workflows, which can be parsed and executed by arbitrary executors, e.g. Cromwell (\url{https://cromwell.readthedocs.io}), Toil~\parencite{Vivian_2017}, and Tibanna~\parencite{Lee_2019}.
Similar to the fourth niche, a downside is that imperative or functional programming is not or less integrated into the specification language, thereby limiting the expressive power.
In contrast, a main advantage is that the same workflow definition can be executed on various specialized execution backends, thereby promising scalability to virtually any computing platform.
Another important use case for system-independent languages is that they promote interoperability between other workflow definition languages.
For example, Snakemake workflows can (within limits) be automatically exported to CWL, and Snakemake can make use of CWL tool definitions.
An automatic translation of any CWL workflow definition into a Snakemake workflow is planned as well.

Today, several of the above mentioned approaches support full in silico reproducibility of data analyses (e.g. Galaxy, Nextflow, Snakemake, WDL, CWL), by allowing the definition and scalable execution of each involved step, including deployment of the software stack needed for each step (e.g. via the Conda package manager,~\url{https://docs.conda.io}, Docker,~\url{https://www.docker.com}, or Singularity~\parencite{kurtzer_singularity_2017} containers).

Reproducibility is important to generate trust in scientific results.
However, we argue that a data analysis is only of lasting and sustained value for the authors and the scientific field if a hierarchy of additional interdependent properties is ensured (\autoref{fig:sustainability}).

\begin{figure}
    \centering
	\includegraphics[width=\columnwidth]{sustainability-in-wms.pdf}
	\caption{
		Hierarchy of aspects to consider for sustainable data analysis.
		By supporting the top layer, a workflow management system can promote the center layer, and thereby help to obtain true sustainability.
	}\label{fig:sustainability}
\end{figure}

First, to gain full in silico \emph{reproducibility}, a data analysis has to be \emph{automated}, \emph{scalable} to various computational platforms and levels of parallelism, and \emph{portable} in the sense that it is able to be automatically deployed with all required software in exactly the needed versions.

Second, while being able to reproduce results is a major achievement, \emph{transparency} is equally important: the validity of results can only be fully assessed if the parameters, software, and custom code of each analysis step are fully accessible.
On the level of the code, a data analysis therefore has to be \emph{readable} and well-\emph{documented}.
On the level of the results it must be possible to \emph{trace} parameters, code, and components of the software stack through all involved steps.

Finally, valid results yielded from a reproducible data analysis have greater meaning to the scientific community if the analysis can be reused for other projects.
In practice, this will almost never be a plain reuse, and instead requires~\emph{adaptability} to new circumstances, for example, being able to extend the analysis, replace or modify steps, and adjust parameter choices.
Such adaptability can only be achieved if the data analysis can easily be executed in a different computational environment (e.g. at a different institute or cloud environment), thus it has to be \emph{scalable} and \emph{portable} again (see \autoref{fig:sustainability}).
In addition, it is crucial that the analysis code is as \emph{readable} as possible such that it can be easily modified.

In this work, we show how data analysis sustainability in terms of these aspects is supported by the open source workflow management system Snakemake (\url{https://snakemake.github.io}).
Since its original publication in 2012, Snakemake has seen hundreds of releases and contributions (\autoref{fig:citations}c).
It has gained wide adoption in the scientific community, culminating in, on average, more than five new citations per week, and over 700 citations in total (Fig.~\ref{fig:citations}a,b).
This makes Snakemake one of the most widely used workflow management systems in science.

\begin{figure}
    \centering
	\includegraphics[width=\columnwidth]{citations+development.pdf}
	\caption{
		Citations and development of Snakemake.
		(a) citations by year of the original Snakemake article (note that the year 2020 is still incomplete at the time of writing).
		(b) citations by scientific discipline of the citing article.
		Data source:~\url{https://badge.dimensions.ai/details/id/pub.1018944052}, 2020/09/29.
		(c) cumulative number of git commits over time; Releases are marked as circles.
		The Snakemake workflow generating the results is available at \url{https://doi.org/10.5281/zenodo.4244143} and a self-contained Snakemake report with workflow code is available as supplementary file.
	}
	\label{fig:citations}
\end{figure}

\section{Methods and Results}

We present how Snakemake enables the researcher to conduct data analyses that have all the properties leading to reproducibility, transparency and adaptability. This in turn allows the analysis to become a sustainable resource both for the researcher themselves and the scientific community. 
We structure the results by each of the properties leading to sustainable data analyses (\autoref{fig:sustainability}).

We will thereby introduce relevant features of both the workflow definition language as well as the execution environment.
Several of them are shared with other tools, while others are (at the time of writing) exclusive to Snakemake.
Finally, there are features that other workflow management systems provide while Snakemake does not (or not yet) offer them.
We intentionally refrain from performing a full comparison with other tools, as we believe that such a view will never be unbiased (and quickly outdated), and should instead be provided by review articles or performed by the potential users based on their individual needs.

\subsection{Automation}\label{sec:automation}

The central idea of Snakemake is that workflows are specified through decomposition into steps represented as~\emph{rules~}(\autoref{fig:example}).
Each rule describes how to obtain a set of output files from a set of input files.
This can happen via a shell command, a block of Python code, an external script (Python, R, or Julia), a Jupyter notebook (\url{https://jupyter.org}), or a so-called wrapper (see Sec.~\ref{sec:modularization}).
Depending on the computing platform used and how Snakemake is configured, input and output files are either stored on disk, or in a remote storage (e.g. FTP, Amazon S3, Google Storage, Microsoft Azure Blob Storage, etc.).
Through the use of wildcards, rules can be generic.
For example, see the rule~\lstinline!select_by_country! in Fig.~\ref{fig:example}a (line 20).
It can be applied to generate any output file of the form~\lstinline!results/by-country/{country}.csv!, with~\lstinline!{country}! being a wildcard that can be replaced with any non-empty string.
In shell commands, input and output files, as well additional parameters, are directly accessible by enclosing the respective keywords in curly braces (in case of more than a single item in any of these, access can happen by name or index).

\begin{figure*}
    \centering
	\includegraphics[width=12cm]{example-workflow.pdf}
	\caption{
		Example Snakemake workflow. (a) workflow definition; hypothesized knowledge requirement for line readability is color-coded on the left next to the line numbers. (b) directed acyclic graph (DAG) of jobs, representing the automatically derived execution plan from the example workflow; job node colors reflect rule colors in the workflow definition. (c) content of script plot-hist.py referred from rule plot\_histogram. (d) knowledge requirements for readability by statement category (see \autoref{sec:morereadability}).
		The example workflow downloads data, plots histograms of city populations within a given list of countries, and converts these from SVG to PDF format.
		Note that this is solely meant as a short yet comprehensive demonstration of the Snakemake syntax.
	}
	\label{fig:example}
\end{figure*}

When using script integration instead of shell commands, Snakemake automatically inserts an object giving access to all properties of the job (e.g. \lstinline!snakemake.output[0]!, see Fig.
\ref{fig:example}c).
This avoids the presence and repetition of boiler plate code for parsing command line arguments.

By replacing wildcards with concrete values, Snakemake turns any rule into a job which will be executed in order to generate the defined output files.

Dependencies between jobs are implicit, and inferred automatically in the following way.
For each input file of a job, Snakemake determines a rule that can generate it---for example by replacing wildcards again (ambiguity can be resolved by prioritization or constraining wildcards)---yielding another job.
Then, Snakemake goes on recursively for the latter, until all input files of all jobs are either generated by another job or already present in the used storage (e.g., on disk).
Where necessary, it is possible to provide arbitrary Python code to infer input files based on wildcard values or even the contents of output files generated by upstream jobs.

From this inference, Snakemake obtains a directed acyclic graph of jobs (DAG, see \autoref{fig:example}b).
The time needed for this is linear in the number of jobs involved in the workflow, and negligible compared to the usual runtimes of the workflow steps (see \autoref{sec:performance}).

\autoref{fig:example}a illustrates all major design patterns needed to define workflows with Snakemake: workflow configuration (line 1), aggregations (line 5-8), specific (line 33-43) and generic (line 45-53) transformations, target rules (line 3-8), log file definition, software stack definition, as well as shell command, script, and wrapper integration.
\autoref{sec:design-patterns} presents additional patterns that are helpful in certain situations (e.g. conditional execution, iteration, exploration of large parameter spaces, benchmarking, scatter/gather).

\subsubsection{Automated unit test generation}

When maintaining and developing a production workflow, it is important to test each contained step, ideally upon every change to the workflow code.
In software development, such tests are called \emph{unit tests} \cite{huizinga_automated_2007}.
From a given source workflow with already computed results that have been checked for correctness, Snakemake can automatically generate a suite of unit tests, which can be executed via the Pytest framework (\url{https://pytest.org}).
Each unit test consists of the execution of one rule, using input data taken from the source workflow.
The generated results are by default compared byte-by-byte against the results given by in the source workflow.
However, this behavior can be overwritten by the user.
It is advisable to keep the input datasets of the source workflow small in order to ensure that unit tests finish quickly.


\subsection{Readability}

The workflow definition language of Snakemake is designed to allow maximum readability, which is crucial for transparency and adaptability.
For natural-language readability, the occurrence of known words is important.~For example, the Dale-Chall readability formula derives a score from the fraction of potentially unknown words (that do not occur in a list of common words) among all words in a text~\parencite{chall_readability_1995}.
For workflow definition languages, one has to additionally consider whether punctuation and operator usage is intuitively understandable.
When analyzing the above example workflow (Fig.~\ref{fig:example}a) under these aspects, code statements fall into seven categories (\autoref{sec:morereadability}).
In addition, for each statement, we can judge whether it

\begin{enumerate}
	\item needs domain knowledge (from the field analyzed in the given workflow),
	\item needs technical knowledge (e.g. about Unix-style shell commands or Python),
	\item needs Snakemake knowledge,
	\item is trivial (i.e., it should be understandable for everybody).
\end{enumerate}

In \autoref{fig:example}, we hypothesize the required knowledge for readability of each code line.
Most statements are understandable with either general education, domain, or technical knowledge.
In particular, only five lines need Snakemake-specific knowledge (\autoref{fig:example}d).
The rationale for each hypothesis can be found in \autoref{sec:morereadability}.

While this example is obviously not as evolved as a real-world data analysis, the ratio of lines requiring Snakemake knowledge, and lines that are trivial or readable with domain or technical knowledge can be expected to stay roughly the same.
Since Snakemake supports modularization of workflow definitions, it is moreover possible to hide more technical parts of the workflow definition (e.g. helper functions or variables), in order to not distract the reader from understanding the main steps of the data analysis.

Since dependencies between jobs are implicitly encoded via matching filename patterns, we hypothesize that, in general, no specific technical knowledge is necessary to understand the connections between the rules (except for special cases like conditional or dynamically determined dependencies). 
The file-centric description of workflows makes it intuitive to to infer dependencies between steps; when the input of one rule reoccurs as the output of another, their link and order of execution is clear.

\subsubsection{Modularization}\label{sec:modularization}

Specific data analysis steps can become quite complicated, for example, when plotting figures or working around idiosyncrasies of external tools.
It helps readability to modularize these away such that the reader of a workflow only has to inspect them if interested in the specific step.
Some of these steps can be quite specific and unique to the analysis.
Others can be common to the scientific field and utilize widely used tools or libraries in a relatively standard way.
For the latter, Snakemake provides the ability to deposit and use \emph{tool wrappers} in/from a central repository.
In contrast, the former can require custom code, often written in scripting languages like R or Python.
Snakemake allows the user to modularize such steps either into scripts or to craft them interactively by integrating with Jupyter notebooks (\url{https://jupyter.org}).

\paragraph{Script integration.}
Integrating a script works via a special \lstinline!script! directive (see \autoref{fig:example}a, line~42).
The referred script does not need any boilerplate code, and can instead directly use all properties of the job (input files, output files, wildcard values, parameters, etc.), which are automatically inserted as a global \lstinline!snakemake! object before the script is executed (see \autoref{fig:example}c).

\paragraph{Jupyter notebook integration.}
Analogous to script integration, a \lstinline!notebook! directive allows a rule to specify a path to a Jupyter notebook.
Via the command line interface, it is possible to instruct Snakemake to open a Jupyter notebook server for editing a notebook in the context of a specific job derived from the rule that refers to the notebook.
The notebook server can be accessed via a web browser in order to interactively program the notebook until the desired results (e.g. a certain plot or figure) are created as intended.
Upon saving the notebook, Snakemake generalizes it such that other jobs from the same rule can subsequently re-use it automatically without the need for another interactive notebook session.

\paragraph{Tool wrappers.}
Reoccurring tools or libraries can be shared between workflows via Snakemake tool wrappers (see \autoref{fig:example}a, line 52-53).
A central public repository (\url{https://snakemake-wrappers.readthedocs.io}) allows the community to share wrappers with each other.
Each wrapper consists of a Python or R script that either uses libraries of the respective scripting language or calls a shell command.
Moreover, each wrapper provides a Conda environment defining the required software stack, including tool and library versions (see \autoref{sec:portability}).
Often, shell command wrappers contain some additional code that works around various idiosyncrasies of the wrapped tool (e.g. dealing with temporary directories or converting job properties into command line arguments).
A wrapper can be used by simply copying and adapting a provided example rule (e.g. by modifying input and output file paths).
Upon execution, the wrapper code and the Conda environment are downloaded from the repository and automatically deployed to the running system.
In addition to single wrappers, the wrapper repository also offers pre-defined, tested combinations of wrappers that constitute entire sub-workflows for common tasks (called meta-wrappers).
This is particularly useful for combinations of steps that reoccur in many data analyses.
All wrappers are automatically tested to run without errors prior to inclusion in the repository, and upon each committed change.

\subsubsection{Standardized code linting and formatting.}\label{sec:style}

The readability of programming code can be heavily influenced by adhering to common style and best practices \parencite{tysell_sundkvist_code_2017}.
Snakemake provides automatic code formatting (via the tool \lstinline!snakefmt!) of workflows, together with any contained Python code.
In addition, Snakemake has a built in \emph{code linter} that detects code violating best practices (e.g. missing directives, indentation issues, missing environment variables, etc.) and provides suggestions on how to improve the code.

\subsection{Portability}\label{sec:portability}

Being able to deploy a data analysis workflow to an unprepared system depends on: (a) the ability to install the workflow management system itself, and (b) the ability to obtain and use the required software stack for each analysis step.
Snakemake itself is easily deployable via the Conda package manager (\url{https://conda.io}), as a Python package (\url{https://pypi.io}), or a Docker container (\url{https://hub.docker.com/r/snakemake/snakemake}).
Instructions and further information can be found at \url{https://snakemake.github.io}.

The management of software stacks needed for individual rules is directly integrated into Snakemake itself, via two complementary mechanisms.

\paragraph{Conda integration}

For each rule, it is possible to define a software environment that will be automatically deployed via the Conda package manager (via a \lstinline!conda! directive, see \autoref{fig:example}a, line 15).
Each environment is described by a lightweight YAML file used by conda to install constituent software.
While efficiently sharing base libraries like Glib with the underlying operating system, software defined in the environment takes precedence over the same software in the operating system, and is isolated and independent from the same software in other Conda environments.

\paragraph{Container integration}

Instead of defining Conda environments, it is also possible to define a container for each rule (via a \lstinline!container! directive, see \autoref{fig:example}a, line 38).
Upon execution, Snakemake will pull the requested container image and run a job inside that container using Singularity \parencite{kurtzer_singularity_2017}.
The advantage of using containers is that the execution environment can be controlled down to the system libraries, and becomes portable across operating systems, thereby further increasing reproducibility \parencite{gruning_practical_2018}.
Containers already exist in centralized repositories for a wide range of scientific software applications, allowing easy integration info Snakemake workflows. 
The downside of using containers is that generating and modifying container images requires additional effort, as well as storage, since the image has to be uploaded to a container registry. 
The storage needed for containers can be minimized during workflow execution by reusing a common container image across multiple workflow steps, or by using step-specific containers comprised of small layers with step-specific customizations on top of a common shared base layer. 
A sweet spot between containers and Conda can be exploited by combining \lstinline!container! and \lstinline!conda! directives.
In that case, Snakemake will generate the requested Conda environment inside of the container, providing the flexibility of Conda together with the additional reproducibility guarantees of containers.

\subsection{Traceability and documentation}

While processing a workflow, Snakemake tracks input files, output files, parameters, software, and code of each executed job.
After completion, this information can be made available via self-contained, interactive, HTML based reports.
Output files in the workflow can be annotated for automatic inclusion in the report.
These features enable the interactive exploration of results alongside information about their provenance.
Since results are included into the report, their presentation does not depend on availability of server backends, making Snakemake reports easily portable and archivable.
In the future, Snakemake reports will be extended to additionally follow the RO-crate standard, which will make them machine-readable and allow an integration with web services like \url{https://workflowhub.eu}.
An example report summarizing the (minimal) data analysis conducted for this article is included as supplementary file ``report.html''.

\subsection{Scalability}\label{sec:scalability}

Being able to scale a workflow to available computational resources is crucial for reproducing previous results as well as adapting a data analysis to novel research questions or datasets.
Like many other state-of-the-art workflow management systems, Snakemake allows workflow execution to scale to various computational platforms, ranging from single workstations to large compute servers, any common cluster middleware, grid computing, and cloud computing (with native support for Kubernetes, the Google Cloud Life Sciences API, Amazon AWS, TES (\url{https://www.ga4gh.org}), and Microsoft Azure, the latter two in an upcoming release).

Snakemake's design ensures that scaling a workflow to a specific platform should only entail the modification of command line parameters.
The workflow itself can remain untouched.
Via configuration profiles, it is possible to persist and share the command line setup of Snakemake for any computing platform (\url{https://github.com/snakemake-profiles/doc}).


\subsubsection{Job scheduling}
\label{sec:scheduling}

Because of their dependencies, not all jobs in a workflow can be executed at the same time.
Instead, one can imagine partitioning the DAG of jobs into three sections: 
those that are already finished,
those that have already been scheduled but are not finished yet,
and those that have not yet been scheduled (\autoref{fig:scheduling}a).
Let us call the jobs in the latter partition $J^o$, the set of \emph{open} jobs.
Within $J^o$, all jobs that have only incoming edges from the partition of finished jobs (or no incoming edge at all) can be scheduled next.
We call this the set~$J$ of \emph{pending} jobs.
The scheduling problem a workflow manager like Snakemake has to solve is to select the subset $E \subseteq J$ that leads to an efficient execution of the workflow, while not exceeding the given resources like hard drive space, I/O capacity and CPU cores.
Snakemake solves the scheduling problem at the beginning of the workflow execution and whenever a job has finished and new jobs become pending.

Efficiency of execution is evaluated according to three criteria.
First, execution should be as fast as possible.
Second, high-priority jobs should be preferred (Snakemake allows prioritization of jobs via the workflow definition and the command line).
Third, temporary output files should be quickly deleted (Snakemake allows output files to be marked as temporary, which leads to their automatic deletion once all consuming jobs have been finished).
An example is shown in Figure~\ref{fig:scheduling}.

\begin{figure}\centering
\includegraphics[width=5cm]{scheduling.pdf}
\caption{
Snakemake scheduling problem. 
(a) Example workflow DAG.
The greenish area depicts the jobs that are ready for scheduling (because all input files are present) at a given time during the workflow execution.
We assume that the red job at the root generates a temporary file, which may be deleted once all blue jobs are finished.
(b) Suboptimal scheduling solution: two green jobs are scheduled, such that only one blue job can be scheduled and the temporary file generated by the red job has to remain on disk until all blue jobs are finished in a subsequent scheduling step. 
(c) Optimal scheduling solution: the three blue jobs are scheduled, such that the temporary file generated by the red job can be deleted afterwards.}
\label{fig:scheduling}
\end{figure}

\newcommand{\N}{\mathbb{N}}
\newcommand{\cores}{\text{c}}
\newcommand{\fueralle}{\text{ for all }}
\newcommand{\question}[1]{\textbf{({#1})}}

We solve the scheduling problem via a mixed integer linear program (MILP) as follows.
Let~$R$ be the set of resources used in the workflow (e.g., CPU cores and memory).
By default, Snakemake only considers CPU cores which we indicate with $\cores$, i.e., $R = \{\cores\}$.
Let~$F$ be the set of temporary files that are currently present.
%% Constants
We first define constants for each pending job $j \in J$: 
Let $p_j \in \N$ be its priority, let $u_{r,j} \in \N$ be its usage of resource $r \in R$, and let $z_{f,j} \in \{0,1\}$ indicate whether it needs temporary file $f \in F$ as input ($z_{f,j}=1$) or not ($z_{f,j}=0$).
Further, let $U_r$ be the free capacity of resource $r \in R$ (initially what is provided to Snakemake on the command line; later what is left, given resources already used in running jobs).
Let $S_f$ be the size of file $f \in F$, and let $S := \sum_{f\in F}\, S_f$ be be total temporary file size (measured in some reasonable unit, such as MB).


%% Variables
Next, we define indicator variables $x_j \in \{0,1\}$ for each job $j \in J$, indicating whether a job is selected for execution ($1$) or not ($0$).
For each temporary file $f \in F$, we define a variable $\delta_f \in [0,1]$ indicating the fraction of consuming jobs that will be scheduled among all open jobs.
We also call this variable the lifetime fraction of temporary file $f$.
In other words, $\delta_f = 1$ means that all consuming jobs will be completed after this scheduling round has been processed, such that the lifetime of that file is over and it can be deleted.
To indicate the latter, we further define a binary variable $\gamma_f \in \{0,1\}$, with $\gamma_f = 1$ representing the case that $f$ can indeed be deleted, in other words, $\gamma_f = 1 \Leftrightarrow \delta_f = 1$.


\begin{table*}
\begin{minipage}[t]{0.54\textwidth}
\textbf{Objective:}
\begin{align}
\text{Maximize}\qquad
    & 2U_\cores \cdot 2S \cdot \sum_{j \in J}\, p_j \cdot x_j
  +   2S \cdot \sum_{j \in J}\, u_{\cores,j} \cdot x_j \qquad \nonumber \\
&{}+   S \cdot \sum_{f \in F}\, S_f \cdot \gamma_f
  +   \sum_{f \in F}\, S_f \cdot \delta_f  \label{objective}
\end{align}
\hspace{0.6cm}subject to
\begin{align}
x_j & \in \{0,1\} && \fueralle j \in J, \nonumber \\
\gamma_f & \in \{0,1\} && \fueralle f \in F, \nonumber \\ 
\delta_f & \in [0,1] && \fueralle f \in F, \nonumber \\
%%
\sum_{j \in J} x_j \cdot u_{r,j} &\leq U_r && \fueralle r \in R,
    \label{cn:resources}\\
\delta_f & \leq \frac{\sum_{j \in J}\, x_j \cdot z_{f,j}}{\sum_{j \in J^o}\, z_{f,j}} && \fueralle f \in F,
    \label{cn:lifetmp}\\
\gamma_f &\leq \delta_f && \fueralle f \in F.
    \label{cn:deltmp}
\end{align}
\end{minipage}\qquad
%%%%
\begin{minipage}[t]{0.44\textwidth}
\textbf{Variables:}\\[1ex]
binary $(x_j)_{j\in J}$: \\
do we schedule job $j\in J$? \\[1ex]
binary $(\gamma_f)_{f\in F}$: \\
can we delete file $f\in F$? \\[1ex]
continuous $(\delta_f)_{f\in F} \in [0,1]$: \\
lifetime fraction of~$f$; see \eqref{cn:lifetmp} \\[2ex]
%%
\textbf{Parameters:}
\begin{align*}
p_j\in\N     :& \quad \text{priority of job $j\in J$} \\
u_{r,j}\in\N :& \quad \text{$j$'s usage of resource~$r$} \\
z_{f,j}\     :& \quad \text{does job~$j\in J^o$ need file~$f$?} \\
U_r\in\N     :& \quad \text{free capacity of resource~$r$}\\
S_f\in\N     :& \quad \text{size of file~$f$} \\
S\in\N       :& \quad \text{sum of file sizes $\sum\nolimits_f\, S_f$} \\
\end{align*}
\end{minipage}
\caption{Mixed integer linear program for Snakemake's scheduling problem.}
\label{tab:milp}
\end{table*}

Then, the scheduling problem can be written as the MILP depicted in Table~\ref{tab:milp}.
The maximization optimizes four criteria, represented by four separate terms in \eqref{objective}.
First, we strive to prefer jobs with high priority.
Second, we aim to maximize the number of used cores, i.e.\ the extent of parallelization.
%\footnote{Snakemake also allows for jobs that use zero cores (i.e.\ $u_{\cores,j} = 0$), hence we add $+1$ to each summand of the second term.}.
%\question{The $+1$ will prefer running more jobs 1-core jobs instead of one job that uses many cores, e.g. consider one 16-core job with value 17 and 16 one-core jobs with total value 32. Why not use $\max\{1, u_{\cores,j}\}$?}
Third, we aim to delete existing temporary files as soon as possible.
Fourth, we try to reduce the lifetime of temporary files that cannot be deleted in this pass.

We consider these four criteria in lexicographical order.
In other words, priority is most important, only upon ties do we consider parallelization.
Given ties while optimizing parallelization, we consider the ability to delete temporary files.
And only given ties when considering the latter, we take the lifetime of all temporary files that cannot be deleted immediately into account.
Technically, this order is enforced by multiplying each criterion sum with a value that is at least as high as the maximum value that the equation right of it can acquire.
Unless the user explicitly requests otherwise, all jobs have the same priority, meaning that in general the optimization problem maximizes the number of used cores while trying to remove as many temporary files as possible.

The constraints \eqref{cn:resources}--\eqref{cn:deltmp} ensure that the variables have the intended meaning and that the computed schedule does not violate resource constraints.
Constraint \eqref{cn:resources} ensures that the available amount $U_r$ of each resource $r \in R$ is not exceeded by the selection.
Constraint \eqref{cn:lifetmp} (together with the fact that $\delta_f$ is being maximized) ensures that $\delta_{f}$ is ineed the lifetime fraction of temporary file $f \in F$.
Note that the sum in the denominator extends over all open jobs, while the numerator only extends over pending jobs.
Constraint \eqref{cn:deltmp} (together with the fact that $\gamma_f$ is being maximized) ensures that $\gamma_f=0$ if and only if $\delta_f < 1$ and hence calculates whether temporary file $f \in F$ can be deleted.

Additional considerations and alternatives, which may be implemented in subsequent releases of Snakemake, are discussed in the Supplement.

\subsubsection{Caching between workflows}\label{sec:caching}

While data analyses usually entail the handling of multiple datasets or samples that are specific to a particular project, they often also rely on retrieval and post-processing of common datasets.
For example, in the life sciences, such datasets include reference genomes and corresponding annotations.
Since such datasets potentially reoccur in many analyses conducted in a lab or at an institute, re-executing the analysis steps for retrieval and post-processing of common datasets as part of individual analyses would waste both disk space and computation time.

Historically, the solution in practice was to compile shared resources with post-processed datasets that could be referred to from the workflow definition.
For example, in the life sciences, this has led to the Illumina iGenomes resource (\url{https://support.illumina.com/sequencing/sequencing\_software/igenome.html}) and the GATK resource bundle (\url{https://gatk.broadinstitute.org/hc/en-us/articles/360035890811-Resource-bundle}).
In addition, in order to provide a more flexible way of selection and retrieval for such shared resources, so-called ``reference management'' systems have been published, like Go Get Data (\url{https://gogetdata.github.io}) and RefGenie (\url{http://refgenie.databio.org}).
Here, the logic for retrieval and post-processing is curated in a set of recipes or scripts, and the resulting resources can be automatically retrieved via command line utilities.
The downside of all these approaches is that the transparency of the data analysis is hampered since the steps taken to obtain the used resources are hidden and less accessible for the reader of the data analysis.

Snakemake provides a new, generic approach to the problem which does not have this downside (see \autoref{fig:caching}).
Leveraging workflow-inherent information, Snakemake can calculate a hash value for each job that unambiguously captures exactly how an output file is generated, prior to actually generating the file.
This hash can be used to store and lookup output files in a central cache (e.g., a folder on the same machine or in a remote storage).
For any output file in a workflow, if the corresponding rule is marked as eligible for caching, Snakemake can obtain the file from the cache if it has been created before in a different workflow or by a different user on the same system, thereby saving computation time, as well as disk space (on local machines, the file can be linked instead of copied).

\begin{figure}
	\centering
	\includegraphics[width=\columnwidth]{caching.pdf}
	\caption{
		Blockchain-hashing based between workflow caching scheme of Snakemake.
		If a job is eligible for caching, its code, parameters, raw input files, software environment and the hashes of its dependencies are used to calculate a SHA-256 hash value, under which the output files are stored in a central cache.
		Subsequent runs of the same job (with the same dependencies) in other workflows can skip the execution and directly take the output files from the cache.
	}
	\label{fig:caching}
\end{figure}

The hash value is calculated in the following way.
Let $J$ be the set of jobs of a workflow.
For any job $j \in J$, let $c_j$ denote its code (shell command, script, wrapper, or notebook), let $P_j = \{(k_i, v_i) \mid i=0,\dots,m\}$ be its set of parameters (with key $k_i$ and JSON-encoded value $v_i$), let $F_j$ be its set of input files that are not created by any other job, and let $s_j$ be a string describing the associated software environment (either a container unique resource identifier, a Conda environment definition, or both).
Then, assuming that job $j \in J$ with dependencies $D_j \subset J$ is the job of interest, we can calculate the hash value as 

\begin{align*}
h(j) = h'\Bigg( &\left(\bigodot_{i=0}^m k_i \odot v_i \right) \odot c_j \odot \\
&\left( \bigodot_{f \in F_j} h'(f) \right) \odot s_j \odot \\
&\left( \bigodot_{j' \in D_j} h(j') \right) \Bigg)
\end{align*}

with $h'$ being the SHA-256 \parencite{Handschuh} hash function, $\odot$ being the string concatenation, and $\bigodot$ being the string concatenation of its operands in lexicographic order.

The hash function $h(j)$ comprehensively describes everything that affects the content of the output files of job~\(j\), namely code, parameters, raw input files, the software environment and the input generated by jobs it depends on.
For the latter, we recursively apply the hash function~\(h\) again.
In other words, for each dependency~\(j' \in D_j\) we include a hash value into the hash of job~\(j\), which is in fact the hashing principle behind blockchains used for cryptocurrency \parencite{narayanan_bitcoin_2016}.
The hash is only descriptive if the workflow developer ensures that the cached result is generated in a deterministic way.
For example, downloading from a URL that yields data which may change over time should be avoided.

\subsubsection{Graph partitioning}\label{sec:partitioning}

A data analysis workflow can contain diverse compute jobs, some of which may be long-running, and some which may complete quickly.
When executing a Snakemake workflow in a cluster or cloud setting, by default, every job will be submitted separately to the underlying queuing system.
For short-running jobs, this can result in a considerable overhead, as jobs wait in a queue, and may also incur additional delays or cost when accessing files from remote storage or network file systems.
To minimize such overhead, Snakemake offers the ability to partition the DAG of jobs into subgraphs that will be submitted together, as a single cluster or cloud job.

Partitioning happens by assigning rules to groups (see \autoref{fig:grouping}).
Upon execution, Snakemake determines connected subgraphs with the same assigned group for each job and submits such subgraphs together (as a so called \emph{group job}) instead of submitting each job separately.
For each group, it is in addition possible to define how many connected subgraphs shall be spanned when submitting (one by default).
This way, it is possible to adjust the partition size to the needs of the available computational platform.
The resource usage of a group job is determined by sorting involved jobs topologically, summing resource usage per level and taking the maximum over all levels.

\begin{figure*}
    \centering
	\includegraphics[width=15cm]{group-jobs.pdf}
	\caption{Job graph partitioning by assigning rules to groups.
		Two rules of the example workflow (\autoref{fig:example}a) are grouped together, (a) spanning one connected component, (b) spanning two connected components, and (c) spanning five connected components.
		Resulting submitted group jobs are represented as grey boxes.
	}\label{fig:grouping}
\end{figure*}

\subsubsection{Streaming}\label{sec:streaming}

Sometimes, intermediate results of a data analysis can be huge, but not important enough to store persistently on disk.
Apart from the option to mark such files as temporary so that Snakemake will automatically delete them once no longer needed, it is also possible to instruct Snakemake to never store them on disk at all by directly streaming their content from the producing job to to the consuming job.
This requires the producing and consuming jobs to run at the same time on the same computing node (then, the output of the producer can be written to a small in-memory buffer; on Unix, this is called a named pipe).
Snakemake ensures this by submitting producer and consumer as a group job (see \autoref{sec:partitioning}).

\section{Further Considerations}\label{sec:further-considerations}

\subsection{Advanced Workflow Design Patterns}\label{sec:design-patterns}

\autoref{fig:design-patterns} shows advanced design patterns which are less common but useful in certain situations.
For brevity, only rule properties that are necessary to understand each example are shown (e.g. omitting log directives and shell commands or script directives).
Below, we explain each example in detail.

\begin{figure*}
	\image{design-patterns.pdf}
	\caption{Additional design patterns for Snakemake workflows.
		For brevity only rule properties that are necessary to understand each example are shown (e.g. omitting log directives and shell commands or script directives).
		(a) scatter/gather process, (b) streaming, (c) non-file parameters, (d) iteration, (e) sample sheet based configuration, (f) conditional execution, (g) benchmarking, (h) parameter space exploration.
		See \autoref{sec:design-patterns} for details.
	}\label{fig:design-patterns}
\end{figure*}

\paragraph{Scatter/gather processes (\autoref{fig:design-patterns}a).}
Snakemake's ability to employ arbitrary Python code for defining a rule's input and output files already enables any kind of scattering, gathering, and aggregations in workflows.
Nevertheless, it can be more readable and scalable to use Snakemake's explicit support for scatter/gather processes.
A Snakemake workflow can have any number of such processes, each of which has a name (here \lstinline!someprocess!).
In this example, the rule \lstinline!scatter! (line 4) splits some data into $n$ items; the rule \lstinline!step2! (line 8) is applied to each item; the rule \lstinline!gather! (line 14) aggregates over the outputs of \lstinline!step2! for each item.
Thereby, $n$ is defined via the \lstinline!scattergather! directive (line 1) at the beginning, which sets $n$ for each scatter/gather process in the workflow.
In addition, $n$ can be set via the command line via the flag \lstinline!--set-scatter!.
For example, here, we could set the number of scatter items to 16 by specifying \lstinline!--set-scatter someprocess=16!.
This enables the user to better scale the data analysis workflow to its computing platform, beyond the defaults provided by the workflow designer.

\paragraph{Streaming (\autoref{fig:design-patterns}b).}
Snakemake allows to stream output between jobs, instead of writing it to disk (see \autoref{sec:streaming}).
Here, the output of rule \lstinline!step1! (line 1) and \lstinline!step2! (line 7) is streamed into rule \lstinline!step3! (line 13).

\paragraph{Non-file parameters (\autoref{fig:design-patterns}c).}
Data analysis steps can need additional non-file input in the form of parameters, that are for example obtained from the workflow configuration (see \autoref{sec:automation}).
Both input files and such non-file parameters can optionally be defined via a Python function, which is evaluated for each job, when wildcard values are known.
In this example, we define a lambda expression (an anonymous function in Python), that retrieves a threshold depending on the value of the wildcard sample (\lstinline!w.sample!, line 7).
Wildcard values are passed as the first positional argument to such functions (here \lstinline!w!, line 7).

\paragraph{Iteration (\autoref{fig:design-patterns}d).}
Sometimes, a certain step in a data analysis workflow needs to be applied iteratively. Snakemake allows to model defining by setting the iteration count variable as a wildcard (here \lstinline!{i}!, line 16). Then, an input function can be used to either request the output of the previous iteration (if \lstinline!i > 0!, line 10) or the initial data (if \lstinline!i == 0!, line 8). Finally, in the rule that requests the final iteration result, the wildcard \lstinline!{i}! is set to the desired count (here \lstinline!10!, line 3).

\paragraph{Sample sheet based configuration (\autoref{fig:design-patterns}e).}
Often, scientific experiments entail multiple samples, for which meta-information is known (e.g. gender, tissue etc. in biomedicine).
Portable encapsulated projects (PEPs, \url{https://pep.databio.org}) are an approach to standardize such information and provide them in a shareable format.
Snakemake workflows can be directly integrated with PEPs, thereby allowing to configure them via meta-information that is contained in the sample sheets defined by the PEP.
Here, a pepfile (line 1) along with a validation schema (line 2) is defined, followed by an aggregation over all samples defined in the contained sample sheet.

\paragraph{Conditional execution (\autoref{fig:design-patterns}f).}
By default, Snakemake determines the entire DAG of jobs upfront, before the first job is executed.
However, sometimes the analysis path that shall be taken depends on some intermediate results.
For example, this is the case when filtering samples based on quality control criteria.
At the beginning of the data analysis, some quality control (QC) step is performed, which yields QC values for each sample.
The actual analysis that shall happen afterwards might be only suitable for samples that pass the QC.
Hence, one might have to filter out samples that do not pass the QC.
Since the QC is an intermediate result of the same data analysis, it can be necessary to determine the part of the DAG that comes downstream of the QC only after QC has been finalized.
Of course, one option is to separate QC and the actual analysis into two workflows, or defining a separate target rule for QC, such that it can be manually completed upfront, before the actual analysis is started.
Alternatively, if QC shall happen automatically as part of the whole workflow, one can make use of Snakemake's conditional execution capabilities.
In the example, we define that the \lstinline!qc! rule shall be a so-called \lstinline!checkpoint!.
Rules can depend on such checkpoints by obtaining their output from a global \lstinline!checkpoints! object (line 2), that is accessed inside of a function, which is passed to the \lstinline!input! directive of the rule (line 11).
This function is re-evaluated after the checkpoint has been executed (and its output files are present), thereby allowing to inspect the content of the checkoint's output files, and decide about the input files based on that.
In this example, the checkpoint rule \lstinline!qc! creates a TSV file, which the function loads, in order to extract only those samples for which the column \lstinline!"some-value"! contains a value greater than $90$ (line 6).
Only for those samples, the file \lstinline!"results/processed/{sample}.txt"! is requested, which is then generated by applying the rule \lstinline!process! for each of these samples.

\paragraph{Benchmarking (\autoref{fig:design-patterns}g).}
Sometimes, a data analysis entails the benchmarking of certain tools in terms of runtime, CPU, and memory consumption.
Snakemake directly supports such benchmarking by defining a \lstinline!benchmark! directive in a rule (line 7).
This directive takes a path to a TSV file.
Upon execution of a job spawned from such a rule, Snakemake will constantly measure CPU and memory consumption, and store averaged results together with runtime information into the given TSV file.
Benchmark files can be input to other rules, for example in order to generate plots or summary statistics.

\paragraph{Parameter space exploration (\autoref{fig:design-patterns}h).}
In Python (and therefore also with Snakemake), large parameter spaces can be represented very well via Pandas \parencite{reback2020pandas,mckinney-proc-scipy-2010} data frames.
When such a parameter space shall be explored by the application of a set of rules to each instance of the space (i.e., each row of the data frame), the idiomatic approach in Snakemake is to encode each data frame column as a wildcard and request all occuring combinations of values (i.e., the data frame rows), by some consuming rule.
However, with large parameter spaces that have a lot of columns, the wildcard expressions could become cumbersome to write down explicitly in the Snakefile.
Therefore, Snakemake provides a helper called \lstinline!Paramspace!, which can wrap a Pandas data frame (this functionality was inspired by the JUDI workflow management system \url{https://pyjudi.readthedocs.io}).
The helper allows to retrieve a wildcard pattern (via the property \lstinline!wildcard_pattern!) that encodes each column of the data frame in the form \lstinline!name~{name}! (i.e., column name followed by the wildcard/wildcard value).
The wildcard pattern can be formatted into input or output file names of rules (line 15).
The method \lstinline!instance! of the \lstinline!Paramspace! object, automatically returns the corresponding data frame row (as a Python \lstinline!dict!) for given wildcard values (here, that method is automatically evaluated by Snakemake for each instance of the rule \lstinline!simulate!, line 17).
Finally, aggregation over a parameter space becomes possible via the property \lstinline!instance_patterns!, which retrieves a concrete pattern of above form for each data frame row.
Using the \lstinline!expand! helper, these patterns can be formatted into a file path (line 8-11), thereby modelling an aggregation over the entire parameter space.
Naturally, filtering rows or columns on the paramspace via the usual Pandas methods allows to generate sub-spaces.

\subsection{Readability}
\label{sec:morereadability}

Statements in Snakemake workflow definitions fall into seven categories:
\begin{enumerate}
	\item a natural language word, followed by a colon (e.g.~\lstinline!input:! and~\lstinline!output:!),
	\item the word ``rule'', followed by a name and a colon (e.g. \lstinline!rule convert_to_pdf:!),
	\item a quoted filename pattern (e.g. \lstinline!"{prefix}.pdf"!),
	\item a quoted shell command,
	\item a quoted wrapper identifier,
	\item a quoted container URL
	\item a Python statement.
\end{enumerate}

Below, we list the rationale of our assessment for each category in \autoref{fig:example}:

\begin{enumerate}
	\item The natural language word is either trivially understandable (e.g.\ \lstinline!input:! and \lstinline!output:!) or understandable with technical knowledge (\lstinline!container:! or~\lstinline!conda:!).
	      The colon straightforwardly shows that the content follows next.
	      Only for the wrapper directive (\lstinline!wrapper:!) one needs to have the Snakemake specific knowledge that it is possible to refer to publicly available tool wrappers.
	\item
	      The word ``rule'' is trivially understandable, and when
	      carefully choosing rule names, at most domain knowledge is needed for
	      understanding such statements.
	\item
	      Filename patterns can mostly be understood with domain knowledge,
	      since the file extensions should tell the expert what kind of content
	      will be used or created.
	      We hypothesize that wildcard definitions (e.g.~\lstinline!{country}!) are straightforwardly understandable as a placeholder.
	\item
	      Shell commands will usually need domain and technical knowledge for
	      understanding.
	\item
	      Wrapper identifiers can be understood with Snakemake knowledge only,
	      since one needs to know about the central tool wrapper repository of
	      Snakemake.
	      Nevertheless, with only domain knowledge one can at least conclude that the mentioned tool (last part of the wrapper ID) will be used in the wrapper.
	\item
	      A container URL will usually be understandable with technical
	      knowledge.
	\item
	      Python statements will either need technical knowledge or Snakemake
	      knowledge (when using the Snakemake API, as it happens here with the
	      expand command, which allows to aggregate over a combination of
	      wildcard values).
\end{enumerate}

\subsection{Scheduling}\label{sec:morescheduling}
\begin{figure*}
 \centering
 \includegraphics[width=12cm]{benchmark.pdf}
 \caption{Runtime and memory usage of Snakemake while building the graph of jobs depending on the number of jobs in the workflow. The Snakemake workflow generating the results is available at \url{https://doi.org/10.5281/zenodo.4244143} and a self-contained Snakemake report with workflow code is available as supplementary file.}\label{fig:benchmark}
\end{figure*}

While the first releases of Snakemake used a greedy scheduler, the current implementation aims at using more efficient schedules by solving a mixed integer linear program (MILP) whenever there are free resources.
The current implementation already works well; still, future releases may consider additional objectives:
\begin{itemize}
\item The current formulation leads to fast removal of existing temporary files. In addition, one may control creation of temporary files in the first place, such that only limited space is occupied by temporary files at any time point during workflow execution.
\item It may also be beneficial to initially identify bottleneck jobs in the graph and prioritize them automatically instead of relying on the workflow author to prioritize them.
\end{itemize}
%%
Because we consider different objectives hierarchically and use large constants in the objective function, currently a high solver precision is needed.
If more objectives are considered in the future, an alternative hierarchical formulation may be used:
First find the optimal objective value for the first (or the first two) objectives; then solve another MILP that maximizes less important objectives and ensures via constraints that the optimality of the most important objective(s) is not violated, or stays within, say, 5\% of the optimal value.

We also need to mention a technical detail about the interaction between the scheduler and streams (\autoref{sec:design-patterns}).
Some jobs that take part in handling a data stream may effectively use zero cores (because they mostly wait for data and then only read or write data), i.e.\ they have $u_{\cores,j} = 0$ in the MILP notation, which means that they do not contribute to the objective function. 
We thus replace the MILP objective term that maximizes paralellization ($\sum_{j\in J}\, u_{\cores,j} \cdot x_j$) by the modified term $\sum_{j\in J}\, \max \{ u_{\cores,j}, 1\} \cdot x_j$ to ensure that the weight of any $x_j$ within the sum is at least~$1$.

\subsection{Performance}\label{sec:performance}

When executing a data analysis workflow, running time and resource usage is dominated by the executed jobs and the performance of the libraries and tools used in these.
Nevertheless, Snakemake has to process dependencies between jobs, which can incur some startup time until the actual workflow is executed.
In order to provide an estimate on the amount of time and memory needed for this computation, we took the example workflow from Figure 3 in the main manuscript and artificially inflated it by replicating the countries in the input dataset.
By this, we generated workflows of 10 to 90,000 jobs.
Then, we benchmarked runtime and memory usage of Snakemake for computing the entire graph of jobs on these on a single core of an Intel Core i5 CPU with 1.6~GHz, 8~GB RAM and a Lenovo PCIe SSD (LENSE20512GMSP34MEAT2TA) (\autoref{fig:benchmark}).
It can be seen that both runtime and memory increase linearly, starting from 0.2 seconds with 2.88 MB for 11 jobs and reaching 60 seconds with 1.1 GB for 90,000 jobs.

For future releases of Snakemake, we plan to further improve performance, for example by making use of PyPy (\url{https://www.pypy.org}), and by caching dependency resolution results between subsequent invocations of Snakemake.

\section{Conclusion}

While having been almost the holy grail of data analysis workflow management in recent years and being certainly of high importance, reproducibility alone is not enough to sustain the hours of work that scientists invest in crafting data analyses.
Here, we outlined how the interplay of automation, scalability, portability, readability, traceability, and documentation can help to reach beyond reproducibility, making data analyses adaptable and transparent.
Adaptable data analyses can not only be repeated on the same data, but also be modified and extended for new questions or scenarios, thereby greatly increasing their value for both the scientific community and the original authors.
While reproducibility is a necessary property for checking the validity of scientific results, it is not sufficient.
Being able to reproduce exactly the same figure on a different machine tells us that the analysis is robust and valid from a technical perspective.
However, it does not tell anything about the methodological validity (correctness of statistical assumptions, avoidance of overfitting, etc.).
The latter can only be secured by having a transparent yet accessible view on the analysis code.

By analyzing its readability and presenting its modularization, portability, reporting, scheduling, caching, partitioning, and streaming abilities, we have shown how Snakemake supports all these aspects, thereby providing a comprehensive framework for sustainable data analysis, and enabling an ergonomic, unified, combined representation of any kind of analysis step, from raw data processing, to quality control and fine-grained, interactive exploration and plotting of final results.

\section{Author contributions}
Felix Mölder has designed and implemented the job scheduling mechanism (\autoref{sec:scheduling}; supervised by Johannes Köster and Sven Rahmann) and edited the manuscript.
Kim Philip Jablonski has designed and implemented Jupyter notebook integration (\autoref{sec:modularization}) and edited the manuscript.
Michael Hall and Brice Letcher have designed and implemented automated code formatting (\autoref{sec:style}) and Brice Letcher has edited the manuscript.
Vanessa Sochat has designed and implemented the Google Cloud Life Sciences API execution backend, as well as various improvements to Google storage support (\autoref{sec:scalability}) and edited the manuscript.
Soohyun Lee has designed and implemented the AWS execution backend via integration with Tibanna (\autoref{sec:scalability}).
Sven O.\ Twardziok and Alexander Kanitz have designed and implemented the TES execution backend (\autoref{sec:scalability}).
Andreas Wilm has designed and implemented the Microsoft Azure execution backend (\autoref{sec:scalability}) and edited the manuscript.
Manuel Holtgrewe has designed and implemented benchmarking support (\autoref{sec:design-patterns}).
Jan Forster has designed and implemented meta-wrapper support (\autoref{sec:modularization}).
Christopher Tomkins-Tinch has designed and implemented remote storage support (\autoref{sec:automation}) and edited the manuscript.
Sven Rahmann has edited the manuscript.
Sven Nahnsen has provided the initial idea of using blockchain hashing to fingerprint output files a priori (\autoref{sec:caching}).
Johannes Köster has written the manuscript and implemented all other features that occur in the text but are not explicitly mentioned in above listing.
All authors have read and approved the manuscript.

\section{Acknowledgements}
We are most grateful for the thousands of Snakemake users, their enhancement proposals, bug reports, and efforts to perform sustainable data analyses.
We deeply thank all contributors to the Snakemake, Snakemake-Profile, Snakemake-Workflows, and Snakemake-Wrappers codebases.
This work was supported by the Netherlands Organisation for Scientific Research (NWO) (VENI grant 016.Veni.173.076, Johannes Köster), the German Research Foundation (SFB 876, Johannes Köster and Sven Rahmann), the United States National Science Foundation Graduate Research Fellowship Program (NSF-GRFP) (Grant No. 1745303, Christopher Tomkins-Tinch), and Google LLC (Vanessa Sochat and Johannes Köster).

\printbibliography

\end{document}
