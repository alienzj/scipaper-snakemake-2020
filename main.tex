\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{xr}
\externaldocument{supplement.tex}

\usepackage[backend=biber]{biblatex}
\addbibresource{literature.bib}

\newcommand{\sharedfirst}{$\dagger$}
\newcommand{\sharedfirsttext}[1]{\affil[\sharedfirst]{#1}}
\newcommand{\corresponding}{*}
\newcommand{\correspondingtext}[1]{\affil[\corresponding]{#1}}

\begin{document}

\author[1,2,\sharedfirst]{Felix Mölder}
\author[3,\sharedfirst]{Soo Lee}
\author[4,\sharedfirst]{Michael Hall}
\author[4,\sharedfirst]{Brice Letcher}
\author[5,\sharedfirst]{Vanessa Sochat}
\author[6,\sharedfirst]{Kim Philip Jablonski}
\author[1,7,\corresponding]{Johannes Köster}
\affil[1]{Algorithms for reproducible bioinformatics, Genome Informatics, Institute of Human Genetics, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\affil[2]{Institute of Pathology, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\affil[3]{Biomedical Informatics, Harvard Medical School, Harvard University, Boston, USA}
\affil[4]{EMBL-EBI}
\affil[5]{Stanford Computing, Stanford University}
\affil[6]{ETH Zürich}
\affil[7]{Medical Oncology, Harvard Medical School, Harvard University, Boston, USA}
\sharedfirsttext{Shared first author}
\correspondingtext{To whom correspondence should be addressed}

\title{Insert document title}
\maketitle

\begin{abstract}
	% abstract text
\end{abstract}

Performing data analysis has become ubiquitous across scientific
disciplines. Along with that, securing data analysis reproducibility has
been identified as a major challenge~\parencite{Mesirov2010,Baker2016,Munaf__2017}. In consequence,
recent years have seen a wide adoption of scientific workflow management
systems by the community. Countless workflow management systems have
been published
(see~\url{https://github.com/pditommaso/awesome-pipeline}). Roughly
spoken, these can be partitioned into four niches, for which we will
highlight the major representatives below.~

First, workflow management systems like Galaxy~\parencite{Afgan2018} offer
a graphical user interface for composition and execution of workflows.
The obvious advantage is the shallow learning curve, making such systems
accessible for everybody, without the need for programming skills.

Second, with systems like Anduril~\parencite{Cervera2019},
Balsam~\parencite{papka2018}, Hyperloom~\parencite{cima2018hyperloom},
Jug~\parencite{Coelho_2017}, Pwrake~\parencite{Tanaka_2010},
Ruffus~\parencite{Goodstadt2010}, SciPipe~\parencite{Lampa2019}, SCOOP
\parencite{SCOOP_XSEDE2014}, and COMPSs~\parencite{Lordan_2013} workflows are
specified using~ a set of classes and functions for generic programming
languages like Python, Scala and others. Such systems have the advantage
that they can be used without a graphical interface (e.g. in a server
environment), and that workflows can be straighforwardly managed with
version control systems like Git
(\url{https://git-scm.com}).~

Third, with systems like Nextflow~\parencite{Di_Tommaso_2017},
Snakemake~\selectlanguage{ngerman}\parencite{Köster2012}, BioQueue~\parencite{Yao2017},
Bpipe~\parencite{Sadedin2012}, ClusterFlow~\parencite{Ewels2016},
Cylc~\parencite{J_Oliver_2018},~and BigDataScript~\parencite{Cingolani_2014},
workflows are specified using a domain specific language (DSL). Here,
the advantages of the second niche are shared, while adding the
additional benefit of improved readability since the DSL provides
statements and declarations that specifically model central components
of workflow management, thereby obviating superfluous operators or
boilerplate code. In case of Nextflow and Snakemake, where the DSL is
implemented as an extension to a generic programming language (Groovy
and Python), even access to the full power of the underlying programming
language is maintained (e.g. for implementing conditional execution and
handling configuration).

Fourth, with systems like Popper~\parencite{Jimenez_2017}, workflow
specification happens in a purely declarative way via configuration file
formats like YAML. Here, most of the benefits of the third niche are
shared. In addition, workflow specification can be particularly readable
for non developers. This comes however wit the downside of being more
restricted since the facilities of imperative or functional programming
are not available.

Fifth, there are system-independent workflow specification languages
like CWL~\parencite{cwl} and WDL~\parencite{voss_full-stack_2017}. These define a
(declarative) syntax for specifying workflows, which can be parsed and
executed by arbitrary executors, e.g. Cromwell
(\url{https://cromwell.readthedocs.io}), Toil~\parencite{Vivian_2017} and
Tibanna~\parencite{Lee_2019}. Here, a main advantage is that the same
workflow definition can be executed on various specialized execution
backends, thereby promising scalability to virtually any computing
platform.

Today, several of the above mentioned systems support full in silico
reproducibility of data analyses (e.g. Galaxy, Nextflow, Snakemake, WDL,
CWL), via allowing the definition and automatic scalable execution of
each involved step, together with the ability to define and
automatically deploy the software stack needed for each step (e.g. via
the Conda package manager,~\url{https://docs.conda.io}, or Docker
containers~\url{https://www.docker.com}).

Reproducibility is important to generate trust in scientific results.
However, we postulate that a truly sustainable data analysis needs to
consider a full hierarchy of interdependent aspects (see
Fig.~{\ref{374653}}).

\printbibliography
\end{document}